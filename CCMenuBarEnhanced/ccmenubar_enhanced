#!/bin/bash

# Pro CCMenuBar wrapper with dropdown menu support
# Usage: ccmenubar [command] [arguments]

APP_NAME="CCMenuBar"
DATA_DIR="$HOME/.claude/ccmenubar"
TODOS_FILE="$DATA_DIR/todos.txt"
RECENT_FILE="$DATA_DIR/recent.txt"
STATS_FILE="$DATA_DIR/stats.txt"
COMMANDS_COUNT_FILE="$DATA_DIR/commands_count"
FILES_COUNT_FILE="$DATA_DIR/files_count"

# Ensure data directory exists
mkdir -p "$DATA_DIR"

# Initialize count files if they don't exist
[ ! -f "$COMMANDS_COUNT_FILE" ] && echo "0" > "$COMMANDS_COUNT_FILE"
[ ! -f "$FILES_COUNT_FILE" ] && echo "0" > "$FILES_COUNT_FILE"

# Function to check if app is running
is_running() {
    osascript -e "tell application \"System Events\" to (name of processes) contains \"$APP_NAME\"" 2>/dev/null
}

# Function to set status text
set_status() {
    local text="$1"
    # Escape any quotes in the input text
    text="${text//\"/\\\"}"
    
    # Try to set status
    osascript -e "tell application \"$APP_NAME\" to set_status(\"$text\")" 2>/dev/null
    
    if [ $? -ne 0 ]; then
        echo "Error: Failed to set status. Make sure $APP_NAME is running." >&2
        echo "Start it with: $0 --start" >&2
        return 1
    fi
    
    # Track statistics based on status
    track_stats "$text"
}

# Function to track statistics
track_stats() {
    local status="$1"
    
    # Count commands
    if [[ "$status" == *"🖥️"* ]] || [[ "$status" == *"Shell"* ]]; then
        count=$(<"$COMMANDS_COUNT_FILE")
        echo $((count + 1)) > "$COMMANDS_COUNT_FILE"
    fi
    
    # Count file operations
    if [[ "$status" == *"📝"* ]] || [[ "$status" == *"✏️"* ]] || [[ "$status" == *"📖"* ]]; then
        count=$(<"$FILES_COUNT_FILE")
        echo $((count + 1)) > "$FILES_COUNT_FILE"
    fi
    
    # Update stats file
    update_stats
}

# Function to update statistics
update_stats() {
    local commands=$(<"$COMMANDS_COUNT_FILE")
    local files=$(<"$FILES_COUNT_FILE")
    echo "Commands: $commands | Files: $files" > "$STATS_FILE"
}

# Function to add a TODO
add_todo() {
    local todo="$1"
    if [ -z "$todo" ]; then
        echo "Error: TODO text required" >&2
        return 1
    fi
    
    # Check if TODO already exists
    if grep -Fxq "☐ $todo" "$TODOS_FILE" 2>/dev/null; then
        echo "TODO already exists: $todo"
        return 0
    fi
    
    echo "☐ $todo" >> "$TODOS_FILE"
    echo "Added TODO: $todo"
    
    # Notify via status
    set_status "📝 Added TODO"
}

# Function to complete a TODO
complete_todo() {
    local pattern="$1"
    if [ -z "$pattern" ]; then
        echo "Error: TODO pattern required" >&2
        return 1
    fi
    
    # Find and mark as complete
    if grep -q "☐.*$pattern" "$TODOS_FILE" 2>/dev/null; then
        # Use sed to replace the checkbox
        sed -i.bak "s/☐\(.*$pattern.*\)/✓\1/" "$TODOS_FILE"
        echo "Completed TODO matching: $pattern"
        set_status "✅ TODO completed"
    else
        echo "No uncompleted TODO found matching: $pattern" >&2
        return 1
    fi
}

# Function to remove a TODO
remove_todo() {
    local pattern="$1"
    if [ -z "$pattern" ]; then
        echo "Error: TODO pattern required" >&2
        return 1
    fi
    
    # Remove matching TODO
    if grep -q "$pattern" "$TODOS_FILE" 2>/dev/null; then
        grep -v "$pattern" "$TODOS_FILE" > "$TODOS_FILE.tmp" && mv "$TODOS_FILE.tmp" "$TODOS_FILE"
        echo "Removed TODO matching: $pattern"
        set_status "🗑️ TODO removed"
    else
        echo "No TODO found matching: $pattern" >&2
        return 1
    fi
}

# Function to list TODOs
list_todos() {
    if [ -f "$TODOS_FILE" ] && [ -s "$TODOS_FILE" ]; then
        echo "Current TODOs:"
        cat "$TODOS_FILE"
    else
        echo "No TODOs found."
    fi
}

# Function to clear completed TODOs
clear_completed() {
    if [ -f "$TODOS_FILE" ]; then
        grep -v "^✓" "$TODOS_FILE" > "$TODOS_FILE.tmp" 2>/dev/null && mv "$TODOS_FILE.tmp" "$TODOS_FILE"
        echo "Cleared completed TODOs"
        set_status "🧹 Cleared completed"
    fi
}

# Function to start the app
start_app() {
    if is_running | grep -q "true"; then
        echo "$APP_NAME is already running."
    else
        echo "Starting $APP_NAME..."
        osascript -e "tell application \"$APP_NAME\" to activate" 2>/dev/null
        sleep 1  # Give it a moment to start
        
        if is_running | grep -q "true"; then
            echo "$APP_NAME started successfully."
            # Initialize with current stats
            update_stats
        else
            echo "Failed to start $APP_NAME." >&2
            return 1
        fi
    fi
}

# Function to quit the app
quit_app() {
    if is_running | grep -q "false"; then
        echo "$APP_NAME is not running."
    else
        echo "Quitting $APP_NAME..."
        osascript -e "tell application \"$APP_NAME\" to quit" 2>/dev/null
        echo "$APP_NAME quit successfully."
    fi
}

# Function to reset all data
reset_data() {
    rm -f "$TODOS_FILE" "$RECENT_FILE" "$STATS_FILE" "$COMMANDS_COUNT_FILE" "$FILES_COUNT_FILE"
    echo "0" > "$COMMANDS_COUNT_FILE"
    echo "0" > "$FILES_COUNT_FILE"
    update_stats
    echo "Reset all CCMenuBar data"
    set_status "🔄 Reset complete"
}

# Function to show help
show_help() {
    cat << EOF
CCMenuBar Pro - Claude Code Status Tracker with Dropdown Menu

BASIC USAGE:
    ccmenubar "status text"         Set the status bar text

TODO MANAGEMENT:
    ccmenubar todo add "text"       Add a new TODO
    ccmenubar todo complete "text"  Mark TODO as complete
    ccmenubar todo remove "text"    Remove a TODO
    ccmenubar todo list             List all TODOs
    ccmenubar todo clear-completed  Remove completed TODOs

APP CONTROL:
    ccmenubar --start              Launch CCMenuBar app
    ccmenubar --quit               Quit CCMenuBar app  
    ccmenubar --status             Check if app is running
    ccmenubar --reset              Reset all data and statistics

CLAUDE CODE HOOKS:
    ccmenubar hook <event> <data>  Process Claude Code hook data
    
    Examples:
    ccmenubar hook pretool "bash:ls -la"
    ccmenubar hook posttool "write:success"
    ccmenubar hook notification "Permission needed"

EXAMPLES:
    ccmenubar "🚀 Building project..."
    ccmenubar todo add "Fix login bug"
    ccmenubar todo complete "login"
    ccmenubar hook pretool "bash:npm install"
    
INTEGRATION:
    Use with Claude Code hooks to automatically:
    - Track TODOs from code comments
    - Monitor command execution
    - Display file operation counts
    - Show recent actions in dropdown

DATA FILES:
    TODOs:    ~/.claude/ccmenubar/todos.txt
    Recent:   ~/.claude/ccmenubar/recent.txt
    Stats:    ~/.claude/ccmenubar/stats.txt

Note: The dropdown menu refreshes every 5 seconds to show updated data.
EOF
}

# Function to process Claude Code hooks
process_hook() {
    local event="$1"
    local data="$2"
    
    case "$event" in
        pretool)
            # Extract tool and description
            tool=$(echo "$data" | cut -d: -f1)
            desc=$(echo "$data" | cut -d: -f2-)
            
            case "$tool" in
                bash|shell)
                    set_status "🖥️ $ ${desc:0:30}"
                    ;;
                write|edit)
                    set_status "✏️ ${desc:0:30}"
                    # Check for TODOs in comments
                    if echo "$desc" | grep -i "todo\|fixme\|hack" >/dev/null 2>&1; then
                        todo_text=$(echo "$desc" | grep -oE "(TODO|FIXME|HACK):.*" | head -1)
                        [ -n "$todo_text" ] && add_todo "$todo_text"
                    fi
                    ;;
                read)
                    set_status "📖 ${desc:0:30}"
                    ;;
                *)
                    set_status "⚙️ ${tool}: ${desc:0:20}"
                    ;;
            esac
            ;;
            
        posttool)
            # Handle post-tool results
            if [[ "$data" == *"success"* ]] || [[ "$data" == *"ok"* ]]; then
                set_status "✅ Success"
            elif [[ "$data" == *"error"* ]] || [[ "$data" == *"fail"* ]]; then
                set_status "❌ Failed: ${data:0:20}"
            else
                set_status "✔️ Done"
            fi
            ;;
            
        notification)
            set_status "❗ ${data:0:30}"
            # Also add important notifications as TODOs
            if [[ "$data" == *"fix"* ]] || [[ "$data" == *"error"* ]] || [[ "$data" == *"warning"* ]]; then
                add_todo "Check: $data"
            fi
            ;;
            
        stop)
            set_status "✅ Task complete!"
            update_stats
            ;;
            
        *)
            set_status "📍 ${event}: ${data:0:20}"
            ;;
    esac
}

# Main command processing
case "$1" in
    --help|-h)
        show_help
        ;;
        
    --start)
        start_app
        ;;
        
    --quit)
        quit_app
        ;;
        
    --status)
        if is_running | grep -q "true"; then
            echo "$APP_NAME is running"
            list_todos
            echo "---"
            cat "$STATS_FILE" 2>/dev/null || echo "No statistics yet"
            exit 0
        else
            echo "$APP_NAME is not running"
            exit 1
        fi
        ;;
        
    --reset)
        reset_data
        ;;
        
    todo)
        shift
        case "$1" in
            add)
                shift
                add_todo "$*"
                ;;
            complete|done)
                shift
                complete_todo "$*"
                ;;
            remove|rm|delete)
                shift
                remove_todo "$*"
                ;;
            list|ls)
                list_todos
                ;;
            clear-completed|clear)
                clear_completed
                ;;
            *)
                echo "Unknown todo command: $1" >&2
                echo "Use: todo [add|complete|remove|list|clear-completed]" >&2
                exit 1
                ;;
        esac
        ;;
        
    hook)
        shift
        event="$1"
        shift
        process_hook "$event" "$*"
        ;;
        
    -)
        # Read from stdin
        if is_running | grep -q "false"; then
            echo "Warning: $APP_NAME is not running. Starting it..." >&2
            start_app
        fi
        while IFS= read -r line; do
            set_status "$line"
        done
        ;;
        
    "")
        echo "Error: No command or text provided" >&2
        echo "Usage: ccmenubar \"text\" or ccmenubar [command]" >&2
        echo "Run 'ccmenubar --help' for more options" >&2
        exit 1
        ;;
        
    *)
        # Default: set status text
        if is_running | grep -q "false"; then
            echo "Warning: $APP_NAME is not running. Starting it..." >&2
            start_app
        fi
        set_status "$1"
        ;;
esac
